<?php

/**
 * @file
 * Code for campaign_pages module.
 */

use Drupal\campaign_pages\Handler\ScheduledUpdateListBuilder;
use Drupal\Component\Utility\Random;
use Drupal\Core\Render\Markup;
use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Form\FormStateInterface;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Datetime\Element\Datetime;
use Drupal\Core\Url;
use Drupal\Core\Utility\Error;
use Drupal\file\Entity\File;
use Drupal\image\Entity\ImageStyle;
use Drupal\imagemagick\Plugin\ImageToolkit\ImagemagickToolkit;

/**
 * Implements hook_help().
 */
function campaign_pages_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the campain_pages module.
    case 'help.page.campaign_pages':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Campaign pages functionality') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_theme().
 */
function campaign_pages_theme($existing, $type, $theme, $path) {
  return [
    'field__paragraph__parade_paragraphs__text_boxes' => [
      'base hook' => 'paragraph',
      'path' => $path . '/templates',
    ],
  ];
}

/**
 * Implements hook_field_widget_form_alter().
 */
function campaign_pages_field_widget_form_alter(&$element, FormStateInterface $form_state, $context) {
  // @fixme check for field Type, not name.
  $field_name = $context['items']->getFieldDefinition()->getName();

  // Change dropbuttons to normal list in Paragraphs inline forms.
  if ($field_name === 'field_paragraphs') {
    unset($element['top']['links']['#theme_wrappers']);
    $element['top']['links']['prefix']['#markup'] = '<ul class="paragraph-actions">';
  }

  // Changes to Menu field.
  if ($field_name === 'field_menu') {
    $element['uri']['#description'] = NULL;
    $element['uri']['#title_display'] = 'none';
    $element['title']['#title_display'] = 'none';
  }

  if ($field_name === 'call_to_action' || $field_name === 'parade_call_to_action') {
    $element['title']['#maxlength'] = 32;
  }

  // Remove scheduled updates date description.
  if ($field_name === 'update_timestamp' && isset($context['form']['#entity_type']) && $context['form']['#entity_type'] === 'scheduled_update') {
    $element['value']['#description'] = t('Format: %format.', array('%format' => Datetime::formatExample('Y.m.d. - H:i:s')));
  }

  // Hide empty scheduled updates field if user doesn't have create permission.
  if (($field_name === 'scheduled_publish_date' && !isset($element['entities'][0]) && !\Drupal::currentUser()->hasPermission('create node__moderation_state scheduled updates'))
  || ($field_name === 'scheduled_archive_date' && !isset($element['entities'][0]) && !\Drupal::currentUser()->hasPermission('create node__moderation_state_1 scheduled updates'))) {
    $element['#access'] = FALSE;
  }
}

/**
 * Implements hook_form_alter().
 */
function campaign_pages_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  if (in_array($form_id, ['node_campaign_form', 'node_campaign_edit_form'])) {
    // Menu: Change wording of Add more button.
    $form['field_menu']['widget']['add_more']['#value'] = t('New menu link');

    // Removes the "Add" word from the button values.
    // @todo Get actual display mode instead of default.
    $settings = entity_get_form_display('node', 'campaign', 'default')->getComponent('field_paragraphs')['settings'];
    if ($settings['add_mode'] === 'button') {
      // Add title to the section.
      $field_label = $form['field_paragraphs']['widget']['title']['#value'] ?? $form['field_paragraphs']['widget']['#title'];
      $form['field_paragraphs']['widget']['add_more']['title'] = [
        '#type' => 'table',
        '#header' => [t('Add @type', ['@type' => $field_label])],
        '#attributes' => [
          'class' => ['paragraphs-add-sections-title'],
        ],
        '#weight' => -1,
      ];

      if (isset($form['field_paragraphs']['widget']['add_more'])) {
        foreach ($form['field_paragraphs']['widget']['add_more'] as $key => &$item) {
          if (strpos($key, 'add_more_button_') === 0) {
            $arguments = $item['#value']->getArguments();
            // Adding a context, so it's translatable separatly.
            $options = ['context' => 'add_paragraph_type'];
            $item['#value'] = t('@type', $arguments, $options);
          }
        }
      }
    }

    // Set custom redirection callback to stay on the node form after submit.
    foreach (['submit', 'publish', 'unpublish'] as $action) {
      if (isset($form['actions'][$action])) {
        $form['actions'][$action]['#submit'][] = '_campaign_pages_disable_form_redirect';
      }
    }

    // @todo - duplication because of field machine name.
    if (isset($form['field_paragraphs'])) {
      _parade_conditional_field_add_parade_field_conditions($form, $form_state);

      // @see TCS-361 | Hide color field for text&image
      // when layout is not text1st_enhanced.
      foreach ($form['field_paragraphs']['widget'] as $delta => &$item) {
        if (
          is_numeric($delta)
          && is_array($item)
          && isset($item['subform']['#cache']['tags'])
        ) {
          foreach ($item['subform']['#cache']['tags'] as $tag) {
            // If there are image_text cache tags, it's an image_text type.
            // @todo: Fix this, we should have a more stable condition.
            if (FALSE !== strpos($tag, 'image_text')) {
              $layoutHelperClass = 'parade-layout-states-help-' . (new Random())->name(10, TRUE);
              $item['subform']['parade_layout']['#attributes']['class'][] = $layoutHelperClass;

              $layoutCondition = [".$layoutHelperClass select" => ['value' => 'layout_text_1st_enhanced']];
              $visibleAccordingToLayout = [
                'visible' => $layoutCondition,
              ];
              $item['subform']['parade_color_scheme']['#states'] = $visibleAccordingToLayout;

              // Just skip to the next widget.
              continue 2;
            }
          }
        }
      }
      unset($item);
    }
  }
}

/**
 * Implements hook_element_info_alter().
 *
 * Add element afterbuild for 'container' type - the paragraphs reference
 * subform element.
 *
 * @see parade_conditional_fields_element_after_build()
 */
function campaign_pages_element_info_alter(array &$types) {
  $types['container']['#after_build'][] = 'campaign_pages_element_after_build';
}

/**
 * Add paragraphs bundle machine name to subform wrapper as class.
 */
function campaign_pages_element_after_build($element, FormStateInterface $form_state) {
  if (isset($element['subform'], $element['top']['paragraph_type_title'])) {
    // Add paragraphs bundle machine name to wrapper as class.
    $elementEntity = $form_state->getStorage()['field_storage']['#parents']['#fields']['field_paragraphs']['paragraphs'][$element['#weight']]['entity'];
    if (!empty($elementEntity) && method_exists($elementEntity, 'getType')) {
      $bundle = $elementEntity->getType();
      $element['#prefix'] = str_replace('<div ', '<div class="paragraphs-wrapper-bundle-' . $bundle . '" ', $element['#prefix']);
    }
  }
  return $element;
}

/**
 * Custom redirect for Campaign node submit.
 *
 * @param array &$form
 *   The form build array.
 * @param \Drupal\Core\Form\FormStateInterface $form_state
 *   The form state interface.
 */
function _campaign_pages_disable_form_redirect(array &$form, FormStateInterface $form_state) {
  // Sadly $form_state->disableRedirect() not works as expected, so we also
  // need to redirect to the edit form.
  // @todo Fix redirection of Content Moderation module
  // @see Drupal\content_moderation\EntityType
  $nid = $form_state->getValue('nid');
  $form_state->setRedirect('entity.node.edit_form', ['node' => $nid]);
}

/**
 * Implements hook_entity_operation_alter().
 */
function campaign_pages_entity_operation_alter(array &$operations, EntityInterface $entity) {
  // Remove `destination` URL query parameter on Operations
  // dropbutton for Campaign type nodes.
  if (method_exists($entity, 'getType') && $entity->getType() === 'campaign') {
    foreach ($operations as $operation => $data) {
      if (isset($data['query']['destination'])) {
        unset($operations[$operation]['query']['destination']);
      }
    }
  }
}

/**
 * Implements hook_leaflet_map_info_alter().
 */
function campaign_pages_leaflet_map_info_alter(array &$map_info) {
  // @todo: Maybe use map_info hook and add it as a custom one, not altering the existing.
  // Alter default leaflet map so it displays in black and white.
  if (isset($map_info['OSM Mapnik'])) {
    $map_info['OSM Mapnik']['layers']['earth']['urlTemplate'] = 'http://{s}.tiles.wmflabs.org/bw-mapnik/{z}/{x}/{y}.png';
    $map_info['OSM Mapnik']['icon'] = [
      // Marker has 25 : 41 aspect ratio.
      'iconUrl' => '/' . drupal_get_path('module', 'campaign_pages') . '/images/marker-icon-2x_new.png',
      'iconSize' => [
        // Width.
        'x' => '25',
        // Height.
        'y' => '41',
      ],
      // This is inverted, meaning 12 translates to -12, -12 to 12.
      'iconAnchor' => [
        // Margin left.
        'x' => '12',
        // Margin right.
        'y' => '41',
      ],
      'popupAnchor' => [
        'x' => '0',
        'y' => '-30',
      ],
    ];
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function campaign_pages_form_user_login_form_alter(&$form, FormStateInterface $form_state) {
  $form['#submit'][] = 'campaign_pages_user_login_submit';
}

/**
 * Form submission handler for user_login_form().
 *
 * Redirects the user to the dashboard after logging in.
 */
function campaign_pages_user_login_submit(&$form, FormStateInterface $form_state) {
  $url = Url::fromUri('internal:/admin/content');

  // Check if a destination was set, probably on an exception controller.
  // @see \Drupal\user\Form\UserLoginForm::submitForm()
  $request = \Drupal::service('request_stack')->getCurrentRequest();
  if (!$request->request->has('destination')) {
    $form_state->setRedirectUrl($url);
  }
  else {
    $request->query->set('destination', $request->request->get('destination'));
  }
}

/**
 * Implements hook_entity_type_alter().
 */
function campaign_pages_entity_type_alter(array &$entity_types) {
  if (NULL !== $entity_types['scheduled_update'] && method_exists($entity_types['scheduled_update'], 'setListBuilderClass')) {
    $entity_types['scheduled_update']->setListBuilderClass(ScheduledUpdateListBuilder::class);
  }
}

/**
 * Implements hook_entity_delete().
 *
 * Log paragraph entity deletion.
 */
function campaign_pages_entity_delete($entity) {
  if ($entity->getEntityTypeId() === 'paragraph') {
    \Drupal::logger('campaign_pages')->info('Deleted paragraph ID: ' . $entity->id());
    \Drupal::logger('campaign_pages')->debug('Deleted paragraph backtrace: ' . Error::formatBacktrace(debug_backtrace()));
  }
}

/**
 * Implements hook_preprocess_HOOK().
 */
function campaign_pages_preprocess_status_messages(&$variables) {
  // @see TCS-310.
  // Only execute this code for the scheduled update list route.
  // @note: If we get redirected somewhere else, the str_replace won't work.
  if (FALSE !== strpos(\Drupal::routeMatch()->getRouteName(), 'entity.scheduled_update.collection')) {
    $type = 'status';
    if (isset($variables['message_list'][$type])) {
      $updateTypes = \Drupal::entityTypeManager()->getStorage('scheduled_update_type')->loadMultiple();
      /** @var \Drupal\Core\Render\Markup $message */
      foreach ($variables['message_list'][$type] as &$message) {
        $text = $message->__toString();
        /** @var \Drupal\scheduled_updates\ScheduledUpdateTypeInterface $updateType */
        foreach ($updateTypes as $machineName => $updateType) {
          // If node__moderation_state comes first, but the message contains
          // node__moderation_state_1, then we'd get 'Scheduled update:_1'.
          // So our strpos search includes the closing ':'.
          $searchText = 'content ' . $machineName . ':';
          if (FALSE !== strpos($text, $searchText)) {
            $replacement = 'Scheduled update:';
            $text = str_replace($searchText, $replacement, $text);
            $message = Markup::create($text);
            break;
          }
        }
      }
      unset($message);
    }
  }
}

/**
 * Implements hook_preprocess_HOOK().
 */
function campaign_pages_preprocess_paragraph(&$variables) {
  /** @var Drupal\paragraphs\Entity\Paragraph $paragraph */
  $paragraph = &$variables['paragraph'];

  if (!(method_exists($paragraph, 'getType') && method_exists($paragraph, 'hasField'))) {
    return;
  }

  // Parallax and background stuff for Header and Parallax types.
  // Code from parade. Apply parade_full_hd_width style for
  // header and parallax parade_background fields, if they contain an image.
  if (
    $paragraph->hasField('parade_background') &&
    in_array($paragraph->getType(), ['header', 'parallax'], FALSE)
  ) {
    $target_id = $paragraph->get('parade_background')->target_id;
    if (!$target_id) {
      return;
    }

    // Get background file info.
    $file = File::load($target_id);
    if (NULL !== $file) {
      $file_uri = $file->getFileUri();
      $file_mime = $file->getMimeType();

      // Compress images with an image style.
      if ($file_mime === 'image/jpeg') {
        /** @var Drupal\image\Entity\ImageStyle $style */
        $style = ImageStyle::load('parade_full_hd_width');

        if (NULL === $style) {
          return;
        }

        $variables['parade']['background']['url'] = $style->buildUrl($file_uri);
      }
    }
  }
}

/**
 * Implements hook_imagemagick_arguments_alter().
 *
 * Removes quality argument if it's NULL.
 * It's necessary to avoid errors when quality is empty in the config.
 */
function campaign_pages_imagemagick_arguments_alter(ImagemagickToolkit $toolkit, $command) {
  // @todo: Check if this has been patched in imagemagick.
  if ($command === 'convert' || $command === 'gm') {
    $index = $toolkit->findArgument('-quality');

    if ($index !== FALSE) {
      $quality = $toolkit->getArguments()[$index];

      // Space at the and because NULL casts to an empty string.
      if ($quality === '-quality ') {
        $toolkit->removeArgument($index);
      }
    }
  }
}
