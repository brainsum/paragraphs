{"version":3,"sources":["../../node_modules/rellax/rellax.js","parallax.js"],"names":["Rellax"],"mappings":";;AA4MA,IAAA,GAjMA,SAAA,EAAA,GACA,mBAAA,GAAA,EAAA,IAEA,EAAA,GAAA,GACA,iBAAA,QAAA,OAAA,QAIA,OAAA,QAAA,IAGA,EAAA,OAAA,IAXA,CAaA,KAAA,WACA,IAAA,EAAA,SAAA,EAAA,GACA,aAEA,IAAA,EAAA,OAAA,OAAA,EAAA,WAGA,QAAA,IAAA,OAAA,YAAA,CAEA,IAAA,EAAA,EACA,EAAA,EACA,EAAA,GAIA,EAAA,OAAA,uBACA,OAAA,6BACA,OAAA,0BACA,OAAA,yBACA,OAAA,wBACA,SAAA,GAAA,WAAA,EAAA,IAAA,KA2BA,GAxBA,EAAA,QAAA,CACA,OAAA,GAIA,GACA,OAAA,KAAA,GAAA,QAAA,SAAA,GACA,EAAA,QAAA,GAAA,EAAA,KAKA,EAAA,QAAA,OAAA,GACA,EAAA,QAAA,OAAA,GACA,EAAA,QAAA,MAAA,KACA,EAAA,QAAA,MAAA,IAIA,IACA,EAAA,WAIA,SAAA,uBAAA,EAAA,QAAA,IAAA,KACA,EAAA,MAAA,SAAA,uBAAA,EAAA,QAAA,IAAA,SAIA,CAAA,IAAA,IAAA,SAAA,cAAA,GAMA,MAAA,IAAA,MAAA,qDALA,EAAA,MAAA,cAAA,GAYA,IA0BA,EAAA,SAAA,GAIA,IAEA,EAFA,EAEA,EAAA,wBAAA,IACA,EAAA,EAAA,cAAA,EAAA,cAAA,EAAA,aAGA,GANA,EAMA,EAAA,IAAA,EAAA,GAGA,EAAA,EAAA,QAAA,YAAA,EAAA,QAAA,YAAA,EAAA,QAAA,MAMA,MAAA,CACA,KANA,EAAA,EAAA,GAOA,IAAA,EACA,OAAA,EACA,MAAA,EACA,MAPA,EAAA,MAAA,QAAA,MAAA,MAeA,EAAA,WASA,OARA,IAGA,OADA,IAAA,OAAA,YACA,OAAA,aAEA,SAAA,iBAAA,SAAA,KAAA,YAAA,SAAA,MAAA,YAeA,EAAA,SAAA,EAAA,GACA,IAAA,EAAA,GAAA,KAAA,EAAA,IACA,OAAA,KAAA,MAAA,IAKA,EAAA,WACA,KACA,IAIA,EAAA,IAIA,EAAA,WACA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,IAAA,CACA,IAAA,GAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,GAAA,OAAA,GAMA,EAAA,kBAHA,EAAA,EAAA,EAAA,GAAA,OAAA,EAAA,GAAA,MAGA,QAAA,EAAA,GAAA,MACA,EAAA,MAAA,GAAA,MAAA,QAAA,qBAAA,EAAA,mBAAA,EAAA,cAAA,EAAA,MAOA,OAhHA,WACA,EAAA,OAAA,YACA,IAGA,IAAA,IAAA,EAAA,EAAA,EAAA,EAAA,MAAA,OAAA,IAAA,CACA,IAAA,EAAA,EAAA,EAAA,MAAA,IACA,EAAA,KAAA,GAGA,OAAA,iBAAA,SAAA,WACA,MAIA,IAIA,IA2FA,GACA,OAAA,SACA,IAEA,OAAA;;AClMA,aAFA,IAAA,EAAA,EAAA,QAAA,WAEA,SAAA,EAAA,GAAA,OAAA,GAAA,EAAA,WAAA,EAAA,CAAA,QAAA,GACc,IAAIA,EAAJ,QAAW","file":"parallax.map","sourceRoot":"..\\src\\js","sourcesContent":["\n// ------------------------------------------\n// Rellax.js - v0.2\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts \n// ------------------------------------------\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // Node. Does not work with strict CommonJS, but\n        // only CommonJS-like environments that support module.exports,\n        // like Node.\n        module.exports = factory();\n    } else {\n        // Browser globals (root is window)\n        root.Rellax = factory();\n  }\n}(this, function () {\n  var Rellax = function(el, options){ \n    \"use strict\";\n\n    var self = Object.create(Rellax.prototype);\n\n    // Rellax stays lightweight by limiting usage to desktops/laptops\n    if (typeof window.orientation !== 'undefined') { return; }\n\n    var posY = 0; // set it to -1 so the animate function gets called at least once\n    var screenY = 0;\n    var blocks = [];\n    \n    // check what requestAnimationFrame to use, and if\n    // it's not supported, use the onscroll event\n    var loop = window.requestAnimationFrame ||\n    \twindow.webkitRequestAnimationFrame ||\n    \twindow.mozRequestAnimationFrame ||\n    \twindow.msRequestAnimationFrame ||\n    \twindow.oRequestAnimationFrame ||\n    \tfunction(callback){ setTimeout(callback, 1000 / 60); };\n\n    // Default Settings\n    self.options = {\n      speed: -2\n    };\n\n    // User defined options (might have more in the future)\n    if (options){\n      Object.keys(options).forEach(function(key){\n        self.options[key] = options[key];\n      });\n    }\n\n    // If some clown tries to crank speed, limit them to +-10\n    if (self.options.speed < -10) {\n      self.options.speed = -10;\n    } else if (self.options.speed > 10) {\n      self.options.speed = 10;\n    }\n\n    // By default, rellax class\n    if (!el) {\n      el = '.rellax';\n    }\n\n    // Classes\n    if (document.getElementsByClassName(el.replace('.',''))){\n      self.elems = document.getElementsByClassName(el.replace('.',''));\n    }\n\n    // Now query selector\n    else if (document.querySelector(el) !== false) {\n      self.elems = querySelector(el);\n    }\n\n    // The elements don't exist\n    else {\n      throw new Error(\"The elements you're trying to select don't exist.\");\n    }\n\n\n    // Let's kick this script off\n    // Build array for cached element values\n    // Bind scroll and resize to animate method\n    var init = function() {\n      screenY = window.innerHeight;\n      setPosition();\n\n      // Get and cache initial position of all elements\n      for (var i = 0; i < self.elems.length; i++){\n        var block = createBlock(self.elems[i]);\n        blocks.push(block);\n      }\n\t\t\t\n\t\t\twindow.addEventListener('resize', function(){\n\t\t\t  animate();\n\t\t\t});\n\t\t\t\n\t\t\t// Start the loop\n      update();\n      \n      // The loop does nothing if the scrollPosition did not change\n      // so call animate to make sure every element has their transforms\n      animate();\n    };\n\n\n    // We want to cache the parallax blocks'\n    // values: base, top, height, speed\n    // el: is dom object, return: el cache values\n    var createBlock = function(el) {\n\n      // initializing at scrollY = 0 (top of browser)\n      // ensures elements are positioned based on HTML layout\n      var posY = 0;\n\n      var blockTop = posY + el.getBoundingClientRect().top;\n      var blockHeight = el.clientHeight || el.offsetHeight || el.scrollHeight;\n\n      // apparently parallax equation everyone uses\n      var percentage = (posY - blockTop + screenY) / (blockHeight + screenY);\n\n      // Optional individual block speed as data attr, otherwise global speed\n      var speed = el.dataset.rellaxSpeed ? el.dataset.rellaxSpeed : self.options.speed;\n      var base = updatePosition(percentage, speed);\n\n      // Store non-translate3d transforms\n      var cssTransform = el.style.cssText.slice(11);\n\n      return {\n        base: base,\n        top: blockTop,\n        height: blockHeight,\n        speed: speed,\n        style: cssTransform\n      };\n    };\n\n\n    // set scroll position (posY)\n    // side effect method is not ideal, but okay for now\n    // returns true if the scroll changed, false if nothing happened\n    var setPosition = function() {\n    \tvar oldY = posY;\n    \t\n      if (window.pageYOffset !== undefined) {\n        posY = window.pageYOffset;\n      } else {\n        posY = (document.documentElement || document.body.parentNode || document.body).scrollTop;\n      }\n      \n      if (oldY != posY) {\n      \t// scroll changed, return true\n      \treturn true;\n      }\n      \n      // scroll did not change\n      return false;\n    };\n\n\n    // Ahh a pure function, gets new transform value\n    // based on scrollPostion and speed\n    var updatePosition = function(percentage, speed) {\n      var value = (speed * (100 * (1 - percentage)));\n      return Math.round(value);\n    };\n\n\n    //\n\t\tvar update = function() {\n\t\t\tif (setPosition()) {\n\t\t\t\tanimate();\n\t    }\n\t    \n\t    // loop again\n\t    loop(update);\n\t\t};\n\t\t\n    // Transform3d on parallax element\n    var animate = function() {\n    \tfor (var i = 0; i < self.elems.length; i++){\n        var percentage = ((posY - blocks[i].top + screenY) / (blocks[i].height + screenY));\n\n        // Subtracting initialize value, so element stays in same spot as HTML\n        var position = updatePosition(percentage, blocks[i].speed) - blocks[i].base;\n\n        // Move that element\n        var translate = 'translate3d(0,' + position + 'px' + ',0)' + blocks[i].style;\n        self.elems[i].style.cssText = '-webkit-transform:'+translate+';-moz-transform:'+translate+';transform:'+translate+';';\n      }\n    };\n\n\n    init();\n    Object.freeze();\n    return self;\n  };\n  return Rellax;\n}));","/**\n * @file\n * Initialize parallaxes with Rellax lib.\n *\n * @see  https://github.com/dixonandmoe/rellax\n */\n\nimport Rellax from 'rellax'\n\n(function () {\n\tvar rellax = new Rellax('.parallax');\n})()\n"]}