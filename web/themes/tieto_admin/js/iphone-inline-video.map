{"version":3,"sources":["../../node_modules/intervalometer/dist/intervalometer.es-modules.js","../../node_modules/iphone-inline-video/dist/iphone-inline-video.es-modules.js","iphone-inline-video.js"],"names":["intervalometer","cb","request","cancel","requestParameter","requestId","previousLoopTime","loop","now","start","stop","frameIntervalometer","requestAnimationFrame","cancelAnimationFrame","timerIntervalometer","delay","setTimeout","clearTimeout","enableInlineVideo","preventEvent","element","eventName","test","handler","e","stopImmediatePropagation","addEventListener","proxyProperty","object","propertyName","sourceObject","copyFirst","set","value","Object","defineProperty","get","proxyEvent","dispatchEvent","Event","dispatchEventAsync","type","Promise","resolve","then","iOS8or9","document","head","style","matchMedia","matches","IIV","IIVEvent","IIVPlay","IIVPause","getAudioFromVideo","video","audio","Audio","crossOrigin","src","currentSrc","lastTimeupdateEvent","lastRequests","requestIndex","setTime","time","rememberOnly","Date","currentTime","isPlayerEnded","player","driver","duration","update","timeDiff","readyState","HAVE_FUTURE_DATA","hasAudio","playbackRate","networkState","NETWORK_IDLE","buffered","length","load","ended","pause","play","webkitDisplayingFullscreen","paused","updater","HAVE_ENOUGH_DATA","forceEvents","addPlayer","bind","muted","wasEmpty","autoplay","indexOf","preventWithPropOrFullscreen","el","isAllowed","overloadAPI","opts","everywhere","iPad","ipad","navigator","userAgent","willAutoplay","classList","add","restoreAutoplay","removeEventListener","platform","console","warn","makeVideoPlayableInline","require","querySelector","hasAttribute"],"mappings":"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","file":"iphone-inline-video.map","sourceRoot":"..\\src\\js","sourcesContent":["/*! npm.im/intervalometer */\nfunction intervalometer(cb, request, cancel, requestParameter) {\n\tvar requestId;\n\tvar previousLoopTime;\n\tfunction loop(now) {\n\t\t// must be requested before cb() because that might call .stop()\n\t\trequestId = request(loop, requestParameter);\n\n\t\t// called with \"ms since last call\". 0 on start()\n\t\tcb(now - (previousLoopTime || now));\n\n\t\tpreviousLoopTime = now;\n\t}\n\treturn {\n\t\tstart: function start() {\n\t\t\tif (!requestId) { // prevent double starts\n\t\t\t\tloop(0);\n\t\t\t}\n\t\t},\n\t\tstop: function stop() {\n\t\t\tcancel(requestId);\n\t\t\trequestId = null;\n\t\t\tpreviousLoopTime = 0;\n\t\t}\n\t};\n}\n\nfunction frameIntervalometer(cb) {\n\treturn intervalometer(cb, requestAnimationFrame, cancelAnimationFrame);\n}\n\nfunction timerIntervalometer(cb, delay) {\n\treturn intervalometer(cb, setTimeout, clearTimeout, delay);\n}\n\nexport { intervalometer, frameIntervalometer, timerIntervalometer };","/*! npm.im/iphone-inline-video 2.2.2 */\nimport { frameIntervalometer } from 'intervalometer';\n\nfunction preventEvent(element, eventName, test) {\n\tfunction handler(e) {\n\t\tif (!test || test(element, eventName)) {\n\t\t\te.stopImmediatePropagation();\n\t\t\t// // console.log(eventName, 'prevented on', element);\n\t\t}\n\t}\n\telement.addEventListener(eventName, handler);\n\n\t// Return handler to allow to disable the prevention. Usage:\n\t// const preventionHandler = preventEvent(el, 'click');\n\t// el.removeEventHandler('click', preventionHandler);\n\treturn handler;\n}\n\nfunction proxyProperty(object, propertyName, sourceObject, copyFirst) {\n\tfunction get() {\n\t\treturn sourceObject[propertyName];\n\t}\n\tfunction set(value) {\n\t\tsourceObject[propertyName] = value;\n\t}\n\n\tif (copyFirst) {\n\t\tset(object[propertyName]);\n\t}\n\n\tObject.defineProperty(object, propertyName, {get: get, set: set});\n}\n\nfunction proxyEvent(object, eventName, sourceObject) {\n\tsourceObject.addEventListener(eventName, function () { return object.dispatchEvent(new Event(eventName)); });\n}\n\nfunction dispatchEventAsync(element, type) {\n\tPromise.resolve().then(function () {\n\t\telement.dispatchEvent(new Event(type));\n\t});\n}\n\nvar iOS8or9 = typeof document === 'object' && 'object-fit' in document.head.style && !matchMedia('(-webkit-video-playable-inline)').matches;\n\nvar IIV = 'bfred-it:iphone-inline-video';\nvar IIVEvent = 'bfred-it:iphone-inline-video:event';\nvar IIVPlay = 'bfred-it:iphone-inline-video:nativeplay';\nvar IIVPause = 'bfred-it:iphone-inline-video:nativepause';\n\n/**\n * UTILS\n */\n\nfunction getAudioFromVideo(video) {\n\tvar audio = new Audio();\n\tproxyEvent(video, 'play', audio);\n\tproxyEvent(video, 'playing', audio);\n\tproxyEvent(video, 'pause', audio);\n\taudio.crossOrigin = video.crossOrigin;\n\n\t// 'data:' causes audio.networkState > 0\n\t// which then allows to keep <audio> in a resumable playing state\n\t// i.e. once you set a real src it will keep playing if it was if .play() was called\n\taudio.src = video.src || video.currentSrc || 'data:';\n\n\t// // if (audio.src === 'data:') {\n\t//   TODO: wait for video to be selected\n\t// // }\n\treturn audio;\n}\n\nvar lastRequests = [];\nvar requestIndex = 0;\nvar lastTimeupdateEvent;\n\nfunction setTime(video, time, rememberOnly) {\n\t// Allow one timeupdate event every 200+ ms\n\tif ((lastTimeupdateEvent || 0) + 200 < Date.now()) {\n\t\tvideo[IIVEvent] = true;\n\t\tlastTimeupdateEvent = Date.now();\n\t}\n\tif (!rememberOnly) {\n\t\tvideo.currentTime = time;\n\t}\n\tlastRequests[++requestIndex % 3] = time * 100 | 0 / 100;\n}\n\nfunction isPlayerEnded(player) {\n\treturn player.driver.currentTime >= player.video.duration;\n}\n\nfunction update(timeDiff) {\n\tvar player = this;\n\t// // console.log('update', player.video.readyState, player.video.networkState, player.driver.readyState, player.driver.networkState, player.driver.paused);\n\tif (player.video.readyState >= player.video.HAVE_FUTURE_DATA) {\n\t\tif (!player.hasAudio) {\n\t\t\tplayer.driver.currentTime = player.video.currentTime + ((timeDiff * player.video.playbackRate) / 1000);\n\t\t\tif (player.video.loop && isPlayerEnded(player)) {\n\t\t\t\tplayer.driver.currentTime = 0;\n\t\t\t}\n\t\t}\n\t\tsetTime(player.video, player.driver.currentTime);\n\t} else if (player.video.networkState === player.video.NETWORK_IDLE && player.video.buffered.length === 0) {\n\t\t// This should happen when the source is available but:\n\t\t// - it's potentially playing (.paused === false)\n\t\t// - it's not ready to play\n\t\t// - it's not loading\n\t\t// If it hasAudio, that will be loaded in the 'emptied' handler below\n\t\tplayer.video.load();\n\t\t// // console.log('Will load');\n\t}\n\n\t// // console.assert(player.video.currentTime === player.driver.currentTime, 'Video not updating!');\n\n\tif (player.video.ended) {\n\t\tdelete player.video[IIVEvent]; // Allow timeupdate event\n\t\tplayer.video.pause(true);\n\t}\n}\n\n/**\n * METHODS\n */\n\nfunction play() {\n\t// // console.log('play');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\t// If it's fullscreen, use the native player\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPlay]();\n\t\treturn;\n\t}\n\n\tif (player.driver.src !== 'data:' && player.driver.src !== video.src) {\n\t\t// // console.log('src changed on play', video.src);\n\t\tsetTime(video, 0, true);\n\t\tplayer.driver.src = video.src;\n\t}\n\n\tif (!video.paused) {\n\t\treturn;\n\t}\n\tplayer.paused = false;\n\n\tif (video.buffered.length === 0) {\n\t\t// .load() causes the emptied event\n\t\t// the alternative is .play()+.pause() but that triggers play/pause events, even worse\n\t\t// possibly the alternative is preventing this event only once\n\t\tvideo.load();\n\t}\n\n\tplayer.driver.play();\n\tplayer.updater.start();\n\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'play');\n\t\tif (player.video.readyState >= player.video.HAVE_ENOUGH_DATA) {\n\t\t\t// // console.log('onplay');\n\t\t\tdispatchEventAsync(video, 'playing');\n\t\t}\n\t}\n}\nfunction pause(forceEvents) {\n\t// // console.log('pause');\n\tvar video = this;\n\tvar player = video[IIV];\n\n\tplayer.driver.pause();\n\tplayer.updater.stop();\n\n\t// If it's fullscreen, the developer the native player.pause()\n\t// This is at the end of pause() because it also\n\t// needs to make sure that the simulation is paused\n\tif (video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVPause]();\n\t}\n\n\tif (player.paused && !forceEvents) {\n\t\treturn;\n\t}\n\n\tplayer.paused = true;\n\tif (!player.hasAudio) {\n\t\tdispatchEventAsync(video, 'pause');\n\t}\n\n\t// Handle the 'ended' event only if it's not fullscreen\n\tif (video.ended && !video.webkitDisplayingFullscreen) {\n\t\tvideo[IIVEvent] = true;\n\t\tdispatchEventAsync(video, 'ended');\n\t}\n}\n\n/**\n * SETUP\n */\n\nfunction addPlayer(video, hasAudio) {\n\tvar player = {};\n\tvideo[IIV] = player;\n\tplayer.paused = true; // Track whether 'pause' events have been fired\n\tplayer.hasAudio = hasAudio;\n\tplayer.video = video;\n\tplayer.updater = frameIntervalometer(update.bind(player));\n\n\tif (hasAudio) {\n\t\tplayer.driver = getAudioFromVideo(video);\n\t} else {\n\t\tvideo.addEventListener('canplay', function () {\n\t\t\tif (!video.paused) {\n\t\t\t\t// // console.log('oncanplay');\n\t\t\t\tdispatchEventAsync(video, 'playing');\n\t\t\t}\n\t\t});\n\t\tplayer.driver = {\n\t\t\tsrc: video.src || video.currentSrc || 'data:',\n\t\t\tmuted: true,\n\t\t\tpaused: true,\n\t\t\tpause: function () {\n\t\t\t\tplayer.driver.paused = true;\n\t\t\t},\n\t\t\tplay: function () {\n\t\t\t\tplayer.driver.paused = false;\n\t\t\t\t// Media automatically goes to 0 if .play() is called when it's done\n\t\t\t\tif (isPlayerEnded(player)) {\n\t\t\t\t\tsetTime(video, 0);\n\t\t\t\t}\n\t\t\t},\n\t\t\tget ended() {\n\t\t\t\treturn isPlayerEnded(player);\n\t\t\t}\n\t\t};\n\t}\n\n\t// .load() causes the emptied event\n\tvideo.addEventListener('emptied', function () {\n\t\t// // console.log('driver src is', player.driver.src);\n\t\tvar wasEmpty = !player.driver.src || player.driver.src === 'data:';\n\t\tif (player.driver.src && player.driver.src !== video.src) {\n\t\t\t// // console.log('src changed to', video.src);\n\t\t\tsetTime(video, 0, true);\n\t\t\tplayer.driver.src = video.src;\n\t\t\t// Playing videos will only keep playing if no src was present when .play()’ed\n\t\t\tif (wasEmpty || (!hasAudio && video.autoplay)) {\n\t\t\t\tplayer.driver.play();\n\t\t\t} else {\n\t\t\t\tplayer.updater.stop();\n\t\t\t}\n\t\t}\n\t}, false);\n\n\t// Stop programmatic player when OS takes over\n\tvideo.addEventListener('webkitbeginfullscreen', function () {\n\t\tif (!video.paused) {\n\t\t\t// Make sure that the <audio> and the syncer/updater are stopped\n\t\t\tvideo.pause();\n\n\t\t\t// Play video natively\n\t\t\tvideo[IIVPlay]();\n\t\t} else if (hasAudio && player.driver.buffered.length === 0) {\n\t\t\t// If the first play is native,\n\t\t\t// the <audio> needs to be buffered manually\n\t\t\t// so when the fullscreen ends, it can be set to the same current time\n\t\t\tplayer.driver.load();\n\t\t}\n\t});\n\tif (hasAudio) {\n\t\tvideo.addEventListener('webkitendfullscreen', function () {\n\t\t\t// Sync audio to new video position\n\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t// // console.assert(player.driver.currentTime === video.currentTime, 'Audio not synced');\n\t\t});\n\n\t\t// Allow seeking\n\t\tvideo.addEventListener('seeking', function () {\n\t\t\tif (lastRequests.indexOf(video.currentTime * 100 | 0 / 100) < 0) {\n\t\t\t\t// // console.log('User-requested seeking');\n\t\t\t\tplayer.driver.currentTime = video.currentTime;\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction preventWithPropOrFullscreen(el) {\n\tvar isAllowed = el[IIVEvent];\n\tdelete el[IIVEvent];\n\treturn !el.webkitDisplayingFullscreen && !isAllowed;\n}\n\nfunction overloadAPI(video) {\n\tvar player = video[IIV];\n\tvideo[IIVPlay] = video.play;\n\tvideo[IIVPause] = video.pause;\n\tvideo.play = play;\n\tvideo.pause = pause;\n\tproxyProperty(video, 'paused', player.driver);\n\tproxyProperty(video, 'muted', player.driver, true);\n\tproxyProperty(video, 'playbackRate', player.driver, true);\n\tproxyProperty(video, 'ended', player.driver);\n\tproxyProperty(video, 'loop', player.driver, true);\n\n\t// IIV works by seeking 60 times per second.\n\t// These events are now useless.\n\tpreventEvent(video, 'seeking', function (el) { return !el.webkitDisplayingFullscreen; });\n\tpreventEvent(video, 'seeked', function (el) { return !el.webkitDisplayingFullscreen; });\n\n\t// Limit timeupdate events\n\tpreventEvent(video, 'timeupdate', preventWithPropOrFullscreen);\n\n\t// Prevent occasional native ended events\n\tpreventEvent(video, 'ended', preventWithPropOrFullscreen);\n}\n\nfunction enableInlineVideo(video, opts) {\n\tif ( opts === void 0 ) opts = {};\n\n\t// Stop if already enabled\n\tif (video[IIV]) {\n\t\treturn;\n\t}\n\n\t// Allow the user to skip detection\n\tif (!opts.everywhere) {\n\t\t// Only iOS8 and 9 are supported\n\t\tif (!iOS8or9) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Stop if it's not an allowed device\n\t\tif (!(opts.iPad || opts.ipad ? /iPhone|iPod|iPad/ : /iPhone|iPod/).test(navigator.userAgent)) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// Try to pause\n\tvideo.pause();\n\n\t// Prevent autoplay.\n\t// An non-started autoplaying video can't be .pause()'d\n\tvar willAutoplay = video.autoplay;\n\tvideo.autoplay = false;\n\n\taddPlayer(video, !video.muted);\n\toverloadAPI(video);\n\tvideo.classList.add('IIV');\n\n\t// Autoplay\n\tif (video.muted && willAutoplay) {\n\t\tvideo.play();\n\t\tvideo.addEventListener('playing', function restoreAutoplay() {\n\t\t\tvideo.autoplay = true;\n\t\t\tvideo.removeEventListener('playing', restoreAutoplay);\n\t\t});\n\t}\n\n\tif (!/iPhone|iPod|iPad/.test(navigator.platform)) {\n\t\tconsole.warn('iphone-inline-video is not guaranteed to work in emulated environments');\n\t}\n}\n\nexport default enableInlineVideo;\n","/**\n * @file\n * Allow autoplaying videos on mobile.\n *\n * @see  https://github.com/bfred-it/iphone-inline-video\n */\n\n(function () {\n\n\tconst makeVideoPlayableInline = require('iphone-inline-video');\n\tvar video = document.querySelector('.background-video');\n\tmakeVideoPlayableInline(video, !video.hasAttribute('muted'));\n\n})()\n"]}